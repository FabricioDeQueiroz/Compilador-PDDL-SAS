%{
#include <iostream>
#include <fstream>
#include <string>
#include <cstdlib>
#include <set>

using namespace std;

extern FILE* yyin;

extern int yylineno;

int yylex(void);
int yyparse();

void yyerror(const char *s);

extern char *yytext;  // String do token atual no Flex
extern int yytoken;   // Ãšltimo token processado pelo Bison

std::set<std::string> reqKeys;

void addReqKey(const std::string& req) {
    reqKeys.insert(req);
}

bool hasReqKey(const std::string& req) {
    return reqKeys.count(req) > 0;
}
%}

%union {
    char* str;
    double number;
}

%token <str> IDENTIFIER
%token <str> VARIABLE
%token <number> NUMBER

%token DEFINE DOMAIN REQUIREMENTS TYPES CONSTANTS PREDICATES FUNCTIONS CONSTRAINTS ACTION PARAMETERS PRECONDITION EFFECT DURATIVE_ACTION DURATION CONDITION DERIVED PROBLEM OBJECTS INIT GOAL METRIC TOTAL_TIME LENGTH SERIAL PARALLEL ASSIGN SCALE_UP SCALE_DOWN INCREASE DECREASE MINIMIZE MAXIMIZE AND OR NOT IMPLY FORALL EXISTS WHEN AT OVER START END LT GT EQ LEQ GEQ ALL EITHER

%start argFile

%%

// REV
argFile:
        domain
    |   problem
    ;

// REV
domain:
        '(' DEFINE '(' DOMAIN IDENTIFIER ')'
        reqDef_Opt
        typeDef_Opt
        constDef_Opt
        predDef_Opt
        funcDef_Opt
        structDef_NList ')'
    ;

// REV
reqDef_Opt:
        /* vazio */
    |   reqDef
    ;

// REV
typeDef_Opt:
        /* vazio */
    |   typeDef
    ;

constDef_Opt:
        /* vazio */
    |   constDef
    ;

predDef_Opt:
        /* vazio */
    |   predDef
    ;

funcDef_Opt:
        /* vazio */
    |   funcDef
    ;

structDef_NList:
        /* vazio */
    |   structDef_NList structDef
    ;

// REV
reqDef: 
        '(' ':' REQUIREMENTS reqKey_List ')'
    ;

// REV
reqKey_List:
        reqKey
    |   reqKey_List reqKey
    ;

// REV
reqKey:
        ':' IDENTIFIER { addReqKey($2); }
    ;

// REV
typeDef:
        '(' ':' TYPES typedListName ')'
    ;

// REV
typedListName:
        typedListName_NList
    |   typedListNameList '-' typeType typedListName        { if (!hasReqKey("typing")) { yyerror("Erro"); } } // TODO ver como colocar o arquivo onde ocorreu e a linha
    ;

// REV
typedListName_NList:
        /* vazio */
    |   typedListName_NList IDENTIFIER
    ;

// REV
typedListNameList:
        IDENTIFIER
    |   typedListNameList IDENTIFIER
    ;

// REV
typeType:
        '(' EITHER primitiveTypeList ')'
    |   IDENTIFIER
    ;

// REV
primitiveTypeList:
        IDENTIFIER
    |   primitiveTypeList IDENTIFIER
    ;

constDef:
        '(' ':' CONSTANTS typedListName ')'
    ;

// REV
predDef:
        '(' ':' PREDICATES atomicFormulaSkeletonList ')'
    ;

// REV
atomicFormulaSkeletonList:
        atomicFormulaSkeleton
    |   atomicFormulaSkeletonList atomicFormulaSkeleton
    ;

atomicFormulaSkeleton:
        '(' IDENTIFIER typedListVar ')'
    ;

typedListVar:
        typedListVar_NList
    |   typedListVarList '-' typeType typedListVar        { if (!hasReqKey("typing")) { yyerror("Erro"); } } // TODO ver como colocar o arquivo onde ocorreu e a linha
    ;

typedListVar_NList:
        /* vazio */
    |   typedListVar_NList VARIABLE
    ;

typedListVarList:
        VARIABLE
    |   typedListVarList VARIABLE
    ;

funcDef:
        '(' ':' FUNCTIONS functionTypedList ')'         { if (!hasReqKey("fluents")) { yyerror("Erro"); } } // TODO ver como colocar o arquivo onde ocorreu e a linha
    ;

functionTypedList:
        atomicFormulaSkeletonList
    |   atomicFormulaSkeletonList '-' NUMBER functionTypedList            { if (!hasReqKey("typing")) { yyerror("Erro"); } } // TODO ver como colocar o arquivo onde ocorreu e a linha
    |   /* vazio */
    ;

structDef:
        actionDef
    |   durativeActionDef           { if (!hasReqKey("durative-actions")) { yyerror("Erro"); } } // TODO ver como colocar o arquivo onde ocorreu e a linha
    |   derivedDef                  { if (!hasReqKey("derived-predicates")) { yyerror("Erro"); } } // TODO ver como colocar o arquivo onde ocorreu e a linha
    ;

actionDef:
        '(' ':' ACTION IDENTIFIER ':' PARAMETERS '(' typedListVar ')' actionDefBody ')'
    ;

actionDefBody:
        ':' PRECONDITION goalDef
        ':' EFFECT effect
    |   /* vazio */
    ;

goalDef:
        '(' ')'
    |   atomicFormulaTerm
    |   literalTerm                                         { if (!hasReqKey("negative-preconditions")) { yyerror("Erro"); } } // TODO ver como colocar o arquivo onde ocorreu e a linha
    |   '(' AND goalDef_NList ')'   
    |   '(' OR goalDef_NList ')'                            { if (!hasReqKey("disjunctive-preconditions")) { yyerror("Erro"); } } // TODO ver como colocar o arquivo onde ocorreu e a linha
    |   '(' NOT goalDef ')'                                 { if (!hasReqKey("disjunctive-preconditions")) { yyerror("Erro"); } } // TODO ver como colocar o arquivo onde ocorreu e a linha
    |   '(' IMPLY goalDef goalDef ')'                       { if (!hasReqKey("disjunctive-preconditions")) { yyerror("Erro"); } } // TODO ver como colocar o arquivo onde ocorreu e a linha
    |   '(' EXISTS '(' typedListVar_NList ')' goalDef ')'   { if (!hasReqKey("existential-preconditions")) { yyerror("Erro"); } } // TODO ver como colocar o arquivo onde ocorreu e a linha
    |   '(' FORALL '(' typedListVar_NList ')' goalDef ')'   { if (!hasReqKey("universal-preconditions")) { yyerror("Erro"); } } // TODO ver como colocar o arquivo onde ocorreu e a linha
    |   fComp                                               { if (!hasReqKey("fluents")) { yyerror("Erro"); } } // TODO ver como colocar o arquivo onde ocorreu e a linha
    ;

atomicFormulaTerm:
        '(' PREDICATES term_NList ')'
    ;

term_NList:
        term_NList term
    |   /* vazio */
    ;

term:
        VARIABLE
    |   IDENTIFIER
    ;

literalTerm:
        atomicFormulaTerm
    |   '(' NOT atomicFormulaTerm ')'
    ;

goalDef_NList:
        goalDef_NList goalDef
    |   /* vazio */
    ;

typedListVar_NList:
        typedListVar_NList typedListVar
    |   /* vazio */
    ;

fComp:
        '(' binaryComp fExp fExp ')'
    ;

binaryComp:
        GT
    |   LT
    |   EQ
    |   GEQ
    |   LEQ
    ;

fExp:
        NUMBER
    |   '(' binaryOp fExp fExp ')'
    |   '(' '-' fExp ')'
    |   fHead
    ;

binaryOp:
        '+'
    |   '-'
    |   '*'
    |   '/'
    ;

fHead:
        '(' IDENTIFIER term_NList ')'
    |   IDENTIFIER
    ;

effect:
        '(' ')'
    |   '(' AND cEffect_NList ')'
    |   cEffect
    ;

cEffect:
        '(' FORALL '(' var_NList ')' effect ')'         { if (!hasReqKey("conditional-effects")) { yyerror("Erro"); } } // TODO ver como colocar o arquivo onde ocorreu e a linha
    |   '(' WHEN goalDef CondEffect ')'                 { if (!hasReqKey("conditional-effects")) { yyerror("Erro"); } } // TODO ver como colocar o arquivo onde ocorreu e a linha
    |   pEffect
    ;

cEffect_NList:
        cEffect_NList cEffect
    |   /* vazio */
    ;

var_NList:
        var_NList VARIABLE
    |   /* vazio */
    ;

CondEffect:
        '(' AND pEffect_NList ')'
    |   pEffect
    ;   

pEffect:
        '(' assignOp fHead fExp ')'
    |   '(' NOT atomicFormulaTerm ')'
    |    atomicFormulaTerm
    |   '(' assignOp fHead fExp ')'                     { if (!hasReqKey("fluents")) { yyerror("Erro"); } } // TODO ver como colocar o arquivo onde ocorreu e a linha
    ;

pEffect_NList:
        pEffect_NList pEffect
    |   /* vazio */
    ;

assignOp:
        ASSIGN
    |   SCALE_UP
    |   SCALE_DOWN
    |   INCREASE
    |   DECREASE
    ;

durativeActionDef:
        '(' ':' DURATIVE_ACTION IDENTIFIER ':' PARAMETERS '(' typedListVar ')' daDefBody ')'
    ;

daDefBody:
        ':' DURATION '(' EQ '?' DURATION fExp ')' ':' CONDITION daGd                            /* TODO ver essa bomba: ':' effect daEffect */ 
    ;

daGd: 
        '(' ')'
    |   timedGd
    |   '(' AND timedGdList ')'
    ;

timedGdList:
        timedGdList timedGd
    |   timedGd
    ;

timedGd:
        '(' AT timeSpecifier goalDef ')'
    |   '(' OVER interval goalDef ')'
    ;

timeSpecifier:
        START
    |   END
    ;

interval:
        ALL
    ;

derivedDef:
        '(' ':' DERIVED typedListVar goalDef ')'
    ;

problem:
        '(' DEFINE '(' PROBLEM IDENTIFIER')'
        '(' ':' DOMAIN IDENTIFIER ')'
        reqDef_Opt
        objctDeclaration_Opt
        init
        goal
        metricSpec_Opt ')'
    ;
    
objctDeclaration_Opt:
        objctDeclaration
    |   /* vazio */
    ;

objctDeclaration: 
        '(' ':' OBJECTS typedListName ')'
    ;
     
init: 
        '(' ':' INIT initEl_NList ')'
    ;

initEl_NList:
        initEl_NList initEl
    |   /* vazio */
    ;

initEl:
        literalName
    |   '(' '=' fHead NUMBER ')'                { if (!hasReqKey("fluents")) { yyerror("Erro"); } } // TODO ver como colocar o arquivo onde ocorreu e a linha
    |   '(' AT NUMBER literalName ')'           { if (!hasReqKey("timed-initial-literals")) { yyerror("Erro"); } } // TODO ver como colocar o arquivo onde ocorreu e a linha
    ;

literalName:
        atomicFormulaName
    |   '(' NOT atomicFormulaName ')'
    ;  

atomicFormulaName:
        '(' PREDICATES identifier_NList ')'
    ;

identifier_NList:
        identifier_NList IDENTIFIER
    |   /* vazio */
    ;

goal:
        '(' ':' GOAL goalDef ')'
    ;

metricSpec_Opt:
        metricSpec
    |   /* vazio */
    ;

metricSpec:
        '(' METRIC optimization groundFExp ')'
    ;

optimization:
        MINIMIZE
    |   MAXIMIZE
    ;

groundFExp:
        '(' binaryOp groundFExp groundFExp ')'
    |   '(' '-' groundFExp ')'
    |   NUMBER
    |   '(' IDENTIFIER identifier_NList ')'
    |   TOTAL_TIME
    |   IDENTIFIER
    ;
   
%%

int main(int argc, char **argv) {
    if (argc < 3) {
        cerr << "Uso: " << argv[0] << " <dominio.pddl> <problema.pddl>" << endl;
        return 1;
    }

    yyin = fopen(argv[1], "r");
    if (!yyin) {
        cerr << "Erro ao abrir arquivo: " << argv[1] << endl;
        return 1;
    }

    if (yyparse() != 0) {
        cerr << "Rejected: " << argv[1] << " at line " << yylineno << endl;
        fclose(yyin);

        return 0;
    }

    fclose(yyin);

    yyin = fopen(argv[2], "r");
    if (!yyin) {
        cerr << "Erro ao abrir arquivo: " << argv[2] << endl;
        return 1;
    }

    if (yyparse() != 0) {
        cerr << "Rejected: " << argv[2] << " at line " << yylineno << endl;
        fclose(yyin);

        return 0;
    }

    fclose(yyin);

    cout << "Accepted" << endl;

    return 0;
}

static string errorMessage;

void yyerror(const char *s) {
    errorMessage = s; // Apenas armazena a mensagem de erro
    cout << "Erro na linha " << yylineno << " | TOKEN: " << yytext << endl;
}