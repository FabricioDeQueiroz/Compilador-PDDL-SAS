%{
#include <iostream>
#include <fstream>
#include <string>
#include <cstdlib>
#include <set>

using namespace std;

extern FILE* yyin;

extern int yylineno;

int yylex(void);
int yyparse();

void yyerror(const char *s);

std::set<std::string> reqKeys;

void addReqKey(const std::string& req) {
    requirements.insert(req);
}

bool hasReqKey(const std::string& req) {
    return requirements.count(req) > 0;
}
%}

%union {
    char* str;
    double number;
}

%token <str> IDENTIFIER
%token <str> VARIABLE
%token <number> NUMBER

%token DEFINE DOMAIN REQUIREMENTS TYPES CONSTANTS PREDICATES FUNCTIONS CONSTRAINTS ACTION PARAMETERS PRECONDITION EFFECT DURATIVE_ACTION DURATION CONDITION DERIVED PROBLEM OBJECTS INIT GOAL METRIC TOTAL_TIME LENGTH SERIAL PARALLEL

%token ASSIGN SCALE_UP SCALE_DOWN INCREASE DECREASE

%token MINIMIZE MAXIMIZE

%token AND OR NOT IMPLY

%token FORALL EXISTS

%token WHEN

%token AT OVER START END

%token LT GT EQ LEQ GEQ

%start argFile

%%

argFile:
        domain
    |   problem
    ;

domain:
        '(' DEFINE '(' DOMAIN IDENTIFIER ')'
        reqDef_Opt
        typeDef_Opt
        constDef_Opt
        predDef_Opt
        funcDef_Opt
        constrDef_Opt
        structDef_NList  ')'
    ;

reqDef_Opt:
        reqDef
    |   /* vazio */
    ;

typeDef_Opt:
        typeDef         { if (!hasReqKey("typing")) { yyerror("Erro"); } } // TODO ver como colocar o arquivo onde ocorreu e a linha
    |   /* vazio */
    ;

constDef_Opt:
        constDef
    |   /* vazio */
    ;

predDef_Opt:
        predDef
    |   /* vazio */
    ;

funcDef_Opt:
        funcDef         { if (!hasReqKey("fluents")) { yyerror("Erro"); } } // TODO ver como colocar o arquivo onde ocorreu e a linha
    |   /* vazio */
    ;

constrDef_Opt:
        constrDef
    |   /* vazio */
    ;

structDef_NList:
        structDef_NList structDef
    |   /* vazio */
    ;

reqDef: 
        '(' ':' REQUIREMENTS reqKey_List ')'
    ;

reqKey_List:
        reqKey
    |   reqKey_List reqKey
    ;

reqKey:
        ':' IDENTIFIER { addReqKey($1); }
    ;

typeDef:
        '(' ':' TYPES typedList ')'
    ;

typedList:
        typedListElement
    |   /* vazio */
    ;

typedListElement:
        IDENTIFIER
    |   typedListElementsList 
    ;

typedListElementsList:
        IDENTIFIER
    |   typedListElementsList IDENTIFIER
    |   typedListElementsList IDENTIFIER '-' type typedList
    ;

primitiveTypeList:
        primitiveType
    |   primitiveTypeList primitiveType
    ;

primitiveType:
        IDENTIFIER
    ;

type:
        '(' 'either' primitiveTypeList ')'
    |   primitiveType
    ;

constDef:
        '(' ':' CONSTANTS typedList ')'
    ;

predDef:
        '(' ':' PREDICATES atomicFormulaSkeletonList ')'
    ;

atomicFormulaSkeletonList:
        atomicFormulaSkeleton
    |   atomicFormulaSkeletonList atomicFormulaSkeleton
    ;

atomicFormulaSkeleton:
        '(' IDENTIFIER typedListVar ')'
    ;

typedListVar:
        typedListVarElement
    |   /* vazio */
    ;

typedListVarElement:
        VARIABLE
    |   typedListVarElementsList 
    ;

typedListVarElementsList:
        VARIABLE
    |   typedListVarElementsList VARIABLE
    |   typedListVarElementsList VARIABLE '-' type typedListVar
    ;

funcDef:
        '(' ':' FUNCTIONS functionTypedList ')'
    ;

functionTypedList:
        atomicFormulaSkeletonList       { if (!hasReqKey("numeric-fluents")) { yyerror("Erro"); } } // TODO ver como colocar o arquivo onde ocorreu e a linha
    |   atomicFormulaSkeletonList '-' functionType functionTypedList
    |   /* vazio */
    ;

functionType:
        NUMBER      { if (!hasReqKey("numeric-fluents")) { yyerror("Erro"); } } // TODO ver como colocar o arquivo onde ocorreu e a linha
    |   type        { if (!hasReqKey("typing") || !hasReqKey("object-fluents")) { yyerror("Erro"); } } // TODO ver como colocar o arquivo onde ocorreu e a linha
    ;

%%

int main(int argc, char **argv) {
    if (argc < 3) {
        cerr << "Uso: " << argv[0] << " <dominio.pddl> <problema.pddl>" << endl;
        return 1;
    }
    

    yyin = fopen(argv[1], "r");
    if (!yyin) {
        cerr << "Erro ao abrir arquivo: " << argv[1] << endl;
        return 1;
    }

    if (yyparse() != 0) {
        cerr << "Rejected: " << argv[1] << " at line " << yylineno << endl;
        fclose(yyin);

        return 0;
    }

    fclose(yyin);

    yyin = fopen(argv[2], "r");
    if (!yyin) {
        cerr << "Erro ao abrir arquivo: " << argv[2] << endl;
        return 1;
    }
    

    if (yyparse() != 0) {
        cerr << "Rejected: " << argv[2] << " at line " << yylineno << endl;
        fclose(yyin);

        return 0;
    }

    fclose(yyin);

    cout << "Accepted" << endl;

    return 0;
}

void yyerror(const char *s){
    cerr << "Syntax error at line " << yylineno << ": " << s << endl;
}